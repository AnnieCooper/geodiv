if (length(outfinal) == 1) {
outfinal <- outfinal[[1]]
}
plot(outfinal)
plot(x)
devtools::load_all()
rm(list = c('shift'))
devtools::load_all()
sfd_img <- texture_image(x = x, window = 'square',
size = 5, metric = 'sfd',
parallel = TRUE, ncores = 2, nclumps = 20)
x
metric = 'sfd'
window_type = 'square'
size = 5
in_meters = FALSE
metric = 'sfd'
args = NULL
parallel = TRUE
ncores = 4
nclumps = 20
# change to matrix for faster processing
new_x <- as.matrix(x)
# add padding to matrix and create matrix of same size (all NA) for finding
# which values are extra later
shift <- floor(size / 2)
ext_x <- dummy_ext_x <- pad_edges(new_x, size = shift, val = NA)
dummy_ext_x[] <- NA
# find indices of center, left, right, top, and bottom of each window
start_ind <- 1 + shift
center <- left <- right <- top <- bottom <- dummy_ext_x
# first, set those values to 1 for each side
center[start_ind:(shift + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
left[start_ind:(shift + nrow(new_x)), 1:(ncol(new_x))] <- 1
right[start_ind:(shift + nrow(new_x)), (start_ind + shift):((shift * 2) + ncol(new_x))] <- 1
top[1:nrow(new_x), (shift + 1):(shift + ncol(new_x))] <- 1
bottom[(start_ind + shift):((shift * 2) + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
# get those indices
center_inds <- which(center == 1)
left_inds <- which(left == 1, arr.ind = TRUE)
right_inds <- which(right == 1, arr.ind = TRUE)
top_inds <- which(top == 1, arr.ind = TRUE)
bottom_inds <- which(bottom == 1, arr.ind = TRUE)
# combine window centers and edges into data table
coord_list <- data.frame(center = center_inds, left = left_inds[, 2], right = right_inds[, 2],
top = top_inds[, 1], bottom = bottom_inds[, 1])
# collect arguments
if (!is.null(args)) {
input_args <- args
} else {
input_args <- NULL
}
# sequence of coord rows to run
pixlist <- seq(1, nrow(coord_list))
# get list of # total pixels, break up into smaller lists (by number of cores available)
seg_length <- ceiling(length(pixlist) / nclumps)
segment <- ceiling(length(pixlist) / seg_length)
new_pixlist <- vector('list', segment)
i <- 1
while(i <= segment) {
newi <- ceiling(seq(pixlist[1], max(pixlist), seg_length))[i]
if (i < segment) {
new_pixlist[[i]] <- seq(newi, (newi - 1) + seg_length, 1)
} else {
new_pixlist[[i]] <- seq(newi, max(pixlist), 1)
}
i <- i + 1
}
print('Beginning calculation of metrics over windows...')
start <- Sys.time()
# make and start cluster
try(stopCluster(cl), silent = TRUE)
cl <- makeCluster(ncores, type = 'SOCK')
parallel::clusterExport(cl = cl, list('ext_x', 'coord_list', 'size',
'window_type',
'new_pixlist', 'metric', 'input_args',
'window_metric'),
envir = environment())
parallel::clusterEvalQ(cl, library('geodiv'))
# for each list in new_pixlist, run lapply
result <- parallel::parLapply(cl, new_pixlist, fun = function(l) {
lapply(l, FUN = function(i) {window_metric(x = ext_x, coords = coord_list[i, ],
window_type = window_type,
size = size, metric = metric,
args = input_args)})
})
stopCluster(cl)
end <- Sys.time()
cat('Total time to calculate metrics: ', end - start, '\n', sep = '')
result <- do.call(unlist, args = list(result, recursive = TRUE))
# deal with functions that have multiple outputs
outfinal <- list()
nresult <- length(result) / nrow(coord_list)
nresult
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
# change to matrix for faster processing
new_x <- as.matrix(x)
# add padding to matrix and create matrix of same size (all NA) for finding
# which values are extra later
shift <- floor(size / 2)
ext_x <- dummy_ext_x <- pad_edges(new_x, size = shift, val = NULL)
dummy_ext_x[] <- NA
# find indices of center, left, right, top, and bottom of each window
start_ind <- 1 + shift
center <- left <- right <- top <- bottom <- dummy_ext_x
# first, set those values to 1 for each side
center[start_ind:(shift + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
left[start_ind:(shift + nrow(new_x)), 1:(ncol(new_x))] <- 1
right[start_ind:(shift + nrow(new_x)), (start_ind + shift):((shift * 2) + ncol(new_x))] <- 1
top[1:nrow(new_x), (shift + 1):(shift + ncol(new_x))] <- 1
bottom[(start_ind + shift):((shift * 2) + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
# get those indices
center_inds <- which(center == 1)
left_inds <- which(left == 1, arr.ind = TRUE)
right_inds <- which(right == 1, arr.ind = TRUE)
top_inds <- which(top == 1, arr.ind = TRUE)
bottom_inds <- which(bottom == 1, arr.ind = TRUE)
# combine window centers and edges into data table
coord_list <- data.frame(center = center_inds, left = left_inds[, 2], right = right_inds[, 2],
top = top_inds[, 1], bottom = bottom_inds[, 1])
# collect arguments
if (!is.null(args)) {
input_args <- args
} else {
input_args <- NULL
}
# sequence of coord rows to run
pixlist <- seq(1, nrow(coord_list))
# get list of # total pixels, break up into smaller lists (by number of cores available)
seg_length <- ceiling(length(pixlist) / nclumps)
segment <- ceiling(length(pixlist) / seg_length)
new_pixlist <- vector('list', segment)
i <- 1
while(i <= segment) {
newi <- ceiling(seq(pixlist[1], max(pixlist), seg_length))[i]
if (i < segment) {
new_pixlist[[i]] <- seq(newi, (newi - 1) + seg_length, 1)
} else {
new_pixlist[[i]] <- seq(newi, max(pixlist), 1)
}
i <- i + 1
}
print('Beginning calculation of metrics over windows...')
start <- Sys.time()
# make and start cluster
try(stopCluster(cl), silent = TRUE)
cl <- makeCluster(ncores, type = 'SOCK')
parallel::clusterExport(cl = cl, list('ext_x', 'coord_list', 'size',
'window_type',
'new_pixlist', 'metric', 'input_args',
'window_metric'),
envir = environment())
parallel::clusterEvalQ(cl, library('geodiv'))
# for each list in new_pixlist, run lapply
result <- parallel::parLapply(cl, new_pixlist, fun = function(l) {
lapply(l, FUN = function(i) {window_metric(x = ext_x, coords = coord_list[i, ],
window_type = window_type,
size = size, metric = metric,
args = input_args)})
})
stopCluster(cl)
end <- Sys.time()
cat('Total time to calculate metrics: ', end - start, '\n', sep = '')
result <- do.call(unlist, args = list(result, recursive = TRUE))
# deal with functions that have multiple outputs
outfinal <- list()
nresult <- length(result) / nrow(coord_list)
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
length(pixlist)
nrow(coord_list)
head(coord_lsit)
head(new_x)
head(ext_x)
length(result)
i = 1
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
outfinal[[1]]
outfinal[[i]] <- setValues(outfinal[[i]], t(as.matrix(outfinal[[i]])))
outfinal <- list()
nresult <- length(result) / nrow(coord_list)
for (i in 1:nresult) {
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
outfinal[[i]] <- setValues(outfinal[[i]], t(as.matrix(outfinal[[i]])))
}
if (length(outfinal) == 1) {
outfinal <- outfinal[[1]]
}
plot(outfinal)
devtools::load_all()
rm(shfit)
rm(shift)
gc()
rm(shfit)
devtools::load_all()
sa_img <- texture_image(x = x, window = 'square',
size = 5, metric = 'sa',
parallel = TRUE, ncores = 2, nclumps = 20)
plot(sa_img)
sa_img <- texture_image(x = x, window = 'square',
size = 5, metric = 'sfd',
parallel = TRUE, ncores = 2, nclumps = 20)
plot(sa_img)
sa_img <- texture_image(x = x, window = 'square',
size = 20, metric = 'sfd',
parallel = TRUE, ncores = 2, nclumps = 20)
plot(sa_img)
# Load the orforest data into your active session.
data(orforest)
# plot without trend removed
eviCols <- colorRampPalette(c('lightyellow1', 'darkgreen'))(100)
eviTheme <- rasterVis::rasterTheme(region = eviCols)
(orig_ndvi <- rasterVis::levelplot(orforest, margin = F,
par.settings = eviTheme, xlab = 'Longitude',
ylab = 'Latitude', main='orforest original'))
# plot with trend removed
orfor_rem <- remove_plane(orforest)
(sa <- sa(orforest)) # average roughness
(sbi <- sbi(orforest)) # surface bearing index
(std <- std(orforest, create_plot = FALSE, option = 1))
metric_list <- c('sa', 'sbi', 'std')
system.time(output_rasters2 <- lapply(metric_list, FUN = function(m) {
texture_image(orforest, window_type = 'square', size = 7,
in_meters = FALSE, metric = m,
parallel = TRUE, ncore = 4, nclumps = 20)}))
writeRaster(output_rasters2[[1]], 'C:/Users/lsth490/Box/Smith, Annie/papers/sa_img_450m.tif', overwrite = TRUE)
writeRaster(output_rasters2[[2]], 'C:/Users/lsth490/Box/Smith, Annie/papers/sbi_img_450m.tif', overwrite = TRUE)
writeRaster(output_rasters2[[3]][[1]], 'C:/Users/lsth490/Box/Smith, Annie/papers/std_img_450m.tif', overwrite = TRUE)
url <- fs_download(12834896, mine = FALSE, session = NULL)
# Download rasters from figshare. The list of data returned here will be used
# throughout the vignette.
url <- fs_download(12834896, mine = FALSE, session = NULL)
gc()
library(geodiv)
library(raster)
library(rasterVis)
library(mapdata)
library(maptools)
library(rgeos)
library(ggplot2)
library(tidyverse)
library(parallel)
library(sf)
library(rasterVis)
library(ggmap)
library(corrplot)
library(gridExtra)
library(cowplot)
library(factoextra)
library(cluster)
library(rfigshare)
# Download rasters from figshare. The list of data returned here will be used
# throughout the vignette.
url <- fs_download(12834896, mine = FALSE, session = NULL)
# Download rasters from figshare. The list of data returned here will be used
# throughout the vignette.
url <- fs_download(12834896, mine = FALSE, session = NULL)
knitr::opts_chunk$set(echo = TRUE)
library(geodiv)
library(raster)
library(rasterVis)
library(mapdata)
library(maptools)
library(rgeos)
library(ggplot2)
library(tidyverse)
library(parallel)
library(sf)
library(rasterVis)
library(ggmap)
library(corrplot)
library(gridExtra)
library(cowplot)
library(factoextra)
library(cluster)
library(rfigshare)
# Load the orforest data into your active session.
data(orforest)
# check out the properties of the orforest raster layer.
orforest
# plot without trend removed
eviCols <- colorRampPalette(c('lightyellow1', 'darkgreen'))(100)
eviTheme <- rasterVis::rasterTheme(region = eviCols)
(orig_ndvi <- rasterVis::levelplot(orforest, margin = F,
par.settings = eviTheme, xlab = 'Longitude',
ylab = 'Latitude', main='orforest original'))
# plot with trend removed
orfor_rem <- remove_plane(orforest)
# plot with trend removed
orfor_rem <- remove_plane(orforest)
(orig_rem_plot <- rasterVis::levelplot(orfor_rem, margin = F,
par.settings = eviTheme,
xlab = 'Longitude', ylab = 'Latitude',
main='orforest trend removed'))
(sa <- sa(orforest)) # average roughness
(sbi <- sbi(orforest)) # surface bearing index
(std <- std(orforest, create_plot = FALSE, option = 1))
# Download rasters from figshare. The list of data returned here will be used
# throughout the vignette.
url <- fs_download(12834896, mine = FALSE, session = NULL)
output_rasters2 <- list()
output_rasters2[[1]] <- raster(url[[5]])
output_rasters2[[2]] <- raster(url[[6]])
output_rasters2[[3]] <- raster(url[[7]])
plot(output_rasters2[[1]])
plot(orforest)
plot(output_rasters2[[2]])
plot(output_rasters2[[3]])
orforest
test = crop(orforest, extent(orforest, 0, 100, 0, 50))
test = crop(orforest, extent(orforest, 1, 100, 1, 50))
plot(test)
test2 = texture_image(test, 'square', 5, FALSE, 'sa', TRUE, 4, 20)
rotate <- function(x) {x[] <- rev(x); x}
x = test
window_type = 'square'
size = 5
in_meters = FALSE
metric = 'sfd'
args = NULL
parallel = TRUE
ncores = 4
nclumps = 20
metric = 'sa'
if(Sys.info()['sysname'][[1]] == 'Windows') {
print('mclapply is not supported on Windows, using parLapply instead.')
os_type = 'windows'
} else {
os_type = 'other'
}
# Check if the input is a matrix, and initialize into raster if it is
if ('matrix' %in% base::class(x)) {
# convert to equal area raster
x <- raster(x)
extent(x) <- c(0, ncol(x), 0, nrow(x))
#crs(x) <- paste0('+init=EPSG:', epsg_proj)
crs(x) <- st_crs(5070)$proj4string
}
# Is size argument is in meters, convert it to a number of pixels
if (in_meters == TRUE) {
# get equivalent # pixels of size (this assumes an equal area projection)
size <- ceiling(size / res(x))[1]
}
# change to matrix for faster processing
new_x <- as.matrix(x)
# add padding to matrix and create matrix of same size (all NA) for finding
# which values are extra later
shift <- floor(size / 2)
ext_x <- dummy_ext_x <- pad_edges(new_x, size = shift, val = NULL)
dummy_ext_x[] <- NA
# find indices of center, left, right, top, and bottom of each window
start_ind <- 1 + shift
center <- left <- right <- top <- bottom <- dummy_ext_x
# first, set those values to 1 for each side
center[start_ind:(shift + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
left[start_ind:(shift + nrow(new_x)), 1:(ncol(new_x))] <- 1
right[start_ind:(shift + nrow(new_x)), (start_ind + shift):((shift * 2) + ncol(new_x))] <- 1
top[1:nrow(new_x), (shift + 1):(shift + ncol(new_x))] <- 1
bottom[(start_ind + shift):((shift * 2) + nrow(new_x)), start_ind:(shift + ncol(new_x))] <- 1
# get those indices
center_inds <- which(center == 1)
left_inds <- which(left == 1, arr.ind = TRUE)
right_inds <- which(right == 1, arr.ind = TRUE)
top_inds <- which(top == 1, arr.ind = TRUE)
bottom_inds <- which(bottom == 1, arr.ind = TRUE)
# combine window centers and edges into data table
coord_list <- data.frame(center = center_inds, left = left_inds[, 2], right = right_inds[, 2],
top = top_inds[, 1], bottom = bottom_inds[, 1])
# collect arguments
if (!is.null(args)) {
input_args <- args
} else {
input_args <- NULL
}
# sequence of coord rows to run
pixlist <- seq(1, nrow(coord_list))
# get list of # total pixels, break up into smaller lists (by number of cores available)
seg_length <- ceiling(length(pixlist) / nclumps)
segment <- ceiling(length(pixlist) / seg_length)
new_pixlist <- vector('list', segment)
i <- 1
while(i <= segment) {
newi <- ceiling(seq(pixlist[1], max(pixlist), seg_length))[i]
if (i < segment) {
new_pixlist[[i]] <- seq(newi, (newi - 1) + seg_length, 1)
} else {
new_pixlist[[i]] <- seq(newi, max(pixlist), 1)
}
i <- i + 1
}
print('Beginning calculation of metrics over windows...')
start <- Sys.time()
result <- parallel::mclapply(pixlist, FUN = function(l) {
lapply(l, FUN = function(i) {window_metric(x = ext_x, coords = coord_list[i, ], window_type = window_type,
size = size, metric = metric,
args = input_args)})
}, mc.cores = ncores, mc.cleanup = TRUE)
end <- Sys.time()
cat('Total time to calculate metrics: ', end - start, '\n', sep = '')
result <- do.call(unlist, args = list(result, recursive = TRUE))
print('Beginning calculation of metrics over windows...')
start <- Sys.time()
# make and start cluster
try(stopCluster(cl), silent = TRUE)
cl <- makeCluster(ncores, type = 'SOCK')
parallel::clusterExport(cl = cl, list('ext_x', 'coord_list', 'size',
'window_type',
'new_pixlist', 'metric', 'input_args',
'window_metric'),
envir = environment())
parallel::clusterEvalQ(cl, library('geodiv'))
# for each list in new_pixlist, run lapply
result <- parallel::parLapply(cl, new_pixlist, fun = function(l) {
lapply(l, FUN = function(i) {window_metric(x = ext_x, coords = coord_list[i, ],
window_type = window_type,
size = size, metric = metric,
args = input_args)})
})
stopCluster(cl)
end <- Sys.time()
cat('Total time to calculate metrics: ', end - start, '\n', sep = '')
result <- do.call(unlist, args = list(result, recursive = TRUE))
i = 1
# deal with functions that have multiple outputs
outfinal <- list()
nresult <- length(result) / nrow(coord_list)
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
plot(outfinal)
plot(outfinal[[1]])
test2 = rotate(outfinal[[1]])
plot(tset2)
plot(test2)
devtools::load_all()
rm(list = c("rotate", "sa", "sbi", "shift", "std"))
devtools::load_all()
devtools::document()
window_type = 'square'
size = 5
in_meters = FALSE
metric = 'sa'
args = NULL
parallel = TRUE
ncores = 4
nclumps = 20
data(orforest)
x
temp <- data.frame(newvals = result[seq(i, length(result), nresult)], ind = pixlist)
temprast <- x
temprast[temp$ind] <- temp$newvals
outfinal[[i]] <- temprast
outfinal[[i]] <- trim(outfinal[[i]])
plot(outfinal[[1]])
head(center)
head(left)
head(right)
head(top)
head(bottom)
head(result)
head(pixlist)
head(temp)
tempmat <- matrix(temp$newvals, nrow = nrow(x), ncol = ncol(x))
plot(as.raster(tempmat))
head(tempmat)
x
tempmat
as.raster(tempmat)
raster(tempmat)
plot(raster(tempmat))
devtools::load_all()
texture_image(x, 'square', 5, FALSE, 'sa', parallel = TRUE, ncores = 4, nclumps = 20)
out = texture_image(x, 'square', 5, FALSE, 'sa', parallel = TRUE, ncores = 4, nclumps = 20)
plot(out)
plot(x)
plot(out)
out
x
out = texture_image(orforest, 'square', 5, FALSE, 'sa', parallel = TRUE, ncores = 4, nclumps = 20)
plot(out)
?raster
outfinal[[i]] <- x
outfinal[[i]] <- setValues(x, matrix(temp$newvals, nrow = nrow(x), ncol = ncol(x)))
plot(outfinal[[1]])
devtools::load_all()
out = texture_image(orforest, 'square', 5, FALSE, 'sa', parallel = TRUE, ncores = 4, nclumps = 20)
plot(out)
plot(orforest)
out = texture_image(orforest, 'square', 7, FALSE, 'sa', parallel = TRUE, ncores = 4, nclumps = 20)
plot(otu)
plot(out)
out = focal_metrics(orforest, matrix(1, 5, 5), metrics = list('sa'), progress=TRUE)
plot(out)
plot(out$sa)
plot(output_rasters2[[1]])
