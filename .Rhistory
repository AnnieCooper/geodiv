plot(sa_img$sa)
normforest
window = matrix(1,5,5)
window
metrics = list('sa')
progress = TRUE
number_metrics <- length(metrics)
# get coordinates of cells
points <- landscapemetrics::raster_to_points(x)[, 2:4]
x = normforest
number_metrics <- length(metrics)
# get coordinates of cells
points <- landscapemetrics::raster_to_points(x)[, 2:4]
# resolution of original raster
resolution <- raster::res(x)
# get dimensions of window
n_row <- nrow(window)
n_col <- ncol(window)
# create object for warning messages
warning_messages <- character(0)
result <- withCallingHandlers(expr = {lapply(seq_along(metrics), function(current_metric) {
# print progess using the non-internal name
if (progress) {
cat("\r> Progress metrics: ", current_metric, "/", number_metrics)
}
raster::focal(x = landscape, w = window, fun = function(x) {
.calculate_met_focal(x = x,
n_row = n_row,
n_col = n_col,
resolution = resolution,
points = points,
what = metrics[[current_metric]],
...)},
pad = TRUE, padValue = NA)
})},
warning = function(cond) {
warning_messages <<- c(warning_messages, conditionMessage(cond))
invokeRestart("muffleWarning")})
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
x = x[1:5, 1:5]
x
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
# match function name
foo <- get(what, mode = "function")
# get argument
arguments <- names(formals(foo))[-1]
# get provided arguments
arguments_provided <- substitute(...())
# landscape argument
arguments_values <- list(raster_window)
# sort alphabetically to match later with defaults
if (!is.null(arguments_provided)) {
arguments_provided <- arguments_provided[order(names(arguments_provided))]
# exchange arguments
arguments[arguments %in% names(arguments_provided)] <- arguments_provided
# replace general argument option with specific if na.rm is present
if ("..." %in% arguments & "na.rm" %in% names(arguments_provided)) {
arguments <- c(arguments, arguments_provided[which(names(arguments_provided) == "na.rm")])
}
# remove general dots argument
if ("..." %in% arguments) {
dots_ind <- which(arguments == "...")
arguments <- arguments[-dots_ind]
}
# combine input raster with argument values
arguments_values <- c(arguments_values, arguments)
}
arguments_provided
resolution = resolution
resolution
points = points
what = 'sa'
.calculate_met_focal(x, n_row, ncol, resolution, points, what)
n_row
n_col
x
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
raster_windows
raster_window
#'    \item{\code{'spk'}: reduced peak height}
#'    \item{\code{'scl'}: correlation length}
#'    \item{\code{'sdc'}: bearing area curve height interval}
#' }
#' @references
#' \enumerate{
#' \item{Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019.
#' landscapemetrics: an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).}
#' }
#' @export
.calculate_met_focal <- function(x,
n_row,
n_col,
resolution,
points,
what,
...) {
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
# match function name
foo <- get(what, mode = "function")
# get argument
arguments <- names(formals(foo))[-1]
# get provided arguments
arguments_provided <- substitute(...())
# landscape argument
arguments_values <- list(raster_window)
# sort alphabetically to match later with defaults
if (!is.null(arguments_provided)) {
arguments_provided <- arguments_provided[order(names(arguments_provided))]
# exchange arguments
arguments[arguments %in% names(arguments_provided)] <- arguments_provided
# replace general argument option with specific if na.rm is present
if ("..." %in% arguments & "na.rm" %in% names(arguments_provided)) {
arguments <- c(arguments, arguments_provided[which(names(arguments_provided) == "na.rm")])
}
# remove general dots argument
if ("..." %in% arguments) {
dots_ind <- which(arguments == "...")
arguments <- arguments[-dots_ind]
}
# combine input raster with argument values
arguments_values <- c(arguments_values, arguments)
}
# run function
result <- do.call(what = foo,
args = arguments_values)
return(result)
}
.calculate_met_focal(x, n_row, ncol, resolution, points, what)
class(n_row)
class(n_col)
# get dimensions of window
n_row <- as.numeric(nrow(window))
n_col <- as.numeric(ncol(window))
.calculate_met_focal(x, n_row, ncol, resolution, points, what)
?matrix
class(n_row)
# get dimensions of window
n_row <- nrow(window)
n_col <- ncol(window)
#'    \item{\code{'spk'}: reduced peak height}
#'    \item{\code{'scl'}: correlation length}
#'    \item{\code{'sdc'}: bearing area curve height interval}
#' }
#' @references
#' \enumerate{
#' \item{Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019.
#' landscapemetrics: an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).}
#' }
#' @export
.calculate_met_focal <- function(x,
n_row,
n_col,
resolution,
points,
what,
...) {
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
# match function name
foo <- get(what, mode = "function")
# get argument
arguments <- names(formals(foo))[-1]
# get provided arguments
arguments_provided <- substitute(...())
# landscape argument
arguments_values <- list(raster_window)
print('Made it to 1.')
# sort alphabetically to match later with defaults
if (!is.null(arguments_provided)) {
arguments_provided <- arguments_provided[order(names(arguments_provided))]
# exchange arguments
arguments[arguments %in% names(arguments_provided)] <- arguments_provided
# replace general argument option with specific if na.rm is present
if ("..." %in% arguments & "na.rm" %in% names(arguments_provided)) {
arguments <- c(arguments, arguments_provided[which(names(arguments_provided) == "na.rm")])
}
# remove general dots argument
if ("..." %in% arguments) {
dots_ind <- which(arguments == "...")
arguments <- arguments[-dots_ind]
}
# combine input raster with argument values
arguments_values <- c(arguments_values, arguments)
}
print(arguments_values)
# run function
result <- do.call(what = foo,
args = arguments_values)
return(result)
}
.calculate_met_focal(x, n_row, ncol, resolution, points, what)
.calculate_met_focal(x, n_row, n_col, resolution, points, what)
#'    \item{\code{'spk'}: reduced peak height}
#'    \item{\code{'scl'}: correlation length}
#'    \item{\code{'sdc'}: bearing area curve height interval}
#' }
#' @references
#' \enumerate{
#' \item{Hesselbarth, M.H.K., Sciaini, M., With, K.A., Wiegand, K., Nowosad, J. 2019.
#' landscapemetrics: an open-source R tool to calculate landscape metrics. - Ecography 42:1648-1657(ver. 0).}
#' }
#' @export
.calculate_met_focal <- function(x,
n_row,
n_col,
resolution,
points,
what,
...) {
# convert focal window to matrix
raster_window <- matrix(x, n_row, n_col)
# match function name
foo <- get(what, mode = "function")
# get argument
arguments <- names(formals(foo))[-1]
# get provided arguments
arguments_provided <- substitute(...())
# landscape argument
arguments_values <- list(raster_window)
# sort alphabetically to match later with defaults
if (!is.null(arguments_provided)) {
arguments_provided <- arguments_provided[order(names(arguments_provided))]
# exchange arguments
arguments[arguments %in% names(arguments_provided)] <- arguments_provided
# replace general argument option with specific if na.rm is present
if ("..." %in% arguments & "na.rm" %in% names(arguments_provided)) {
arguments <- c(arguments, arguments_provided[which(names(arguments_provided) == "na.rm")])
}
# remove general dots argument
if ("..." %in% arguments) {
dots_ind <- which(arguments == "...")
arguments <- arguments[-dots_ind]
}
# combine input raster with argument values
arguments_values <- c(arguments_values, arguments)
}
# run function
result <- do.call(what = foo,
args = arguments_values)
return(result)
}
#' # import raster image
#' data(normforest)
#'
#' # get a surface of root mean square roughness
#' sa_img <- focal_metrics(x = normforest, window = matrix(1, 5, 5),
#'                         metrics = list('sa'), progress = TRUE)
#'
#' # plot the result
#' plot(sa_img)
#' @export
focal_metrics <- function(x,
window,
metrics,
progress,
...) {
# check if window has uneven sides
if (any(dim(window) %% 2 == 0)) {
stop("The window must have uneven sides.", call. = FALSE)
}
number_metrics <- length(metrics)
# get coordinates of cells
points <- landscapemetrics::raster_to_points(x)[, 2:4]
# resolution of original raster
resolution <- raster::res(x)
# get dimensions of window
n_row <- nrow(window)
n_col <- ncol(window)
# create object for warning messages
warning_messages <- character(0)
result <- withCallingHandlers(expr = {lapply(seq_along(metrics), function(current_metric) {
# print progess using the non-internal name
if (progress) {
cat("\r> Progress metrics: ", current_metric, "/", number_metrics)
}
raster::focal(x = landscape, w = window, fun = function(x) {
.calculate_met_focal(x = x,
n_row = n_row,
n_col = n_col,
resolution = resolution,
points = points,
what = metrics[[current_metric]],
...)},
pad = TRUE, padValue = NA)
})},
warning = function(cond) {
warning_messages <<- c(warning_messages, conditionMessage(cond))
invokeRestart("muffleWarning")})
names(result) <- metrics
if (progress) {cat("\n")}
# warnings present
if (length(warning_messages) > 0) {
# only unique warnings
warning_messages <- unique(warning_messages)
# print warnings
lapply(warning_messages, function(x){ warning(x, call. = FALSE)})
}
return(result)
}
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sa'), progress = TRUE)
test
head(points)
length(points)
x
x = normforest
x
nrow(points)
#' # import raster image
#' data(normforest)
#'
#' # get a surface of root mean square roughness
#' sa_img <- focal_metrics(x = normforest, window = matrix(1, 5, 5),
#'                         metrics = list('sa'), progress = TRUE)
#'
#' # plot the result
#' plot(sa_img)
#' @export
focal_metrics <- function(x,
window,
metrics,
progress,
...) {
# check if window has uneven sides
if (any(dim(window) %% 2 == 0)) {
stop("The window must have uneven sides.", call. = FALSE)
}
number_metrics <- length(metrics)
# get coordinates of cells
points <- landscapemetrics::raster_to_points(x)[, 2:4]
# resolution of original raster
resolution <- raster::res(x)
# get dimensions of window
n_row <- nrow(window)
n_col <- ncol(window)
# create object for warning messages
warning_messages <- character(0)
result <- withCallingHandlers(expr = {lapply(seq_along(metrics), function(current_metric) {
# print progess using the non-internal name
if (progress) {
cat("\r> Progress metrics: ", current_metric, "/", number_metrics)
}
raster::focal(x = landscape, w = window, fun = function(x) {
.calculate_met_focal(x = x,
n_row = n_row,
n_col = n_col,
resolution = resolution,
points = points,
what = metrics[[current_metric]],
...)},
pad = TRUE, padValue = NA)
})},
warning = function(cond) {
warning_messages <<- c(warning_messages, conditionMessage(cond))
invokeRestart("muffleWarning")})
names(result) <- metrics
if (progress) {cat("\n")}
# warnings present
if (length(warning_messages) > 0) {
# only unique warnings
warning_messages <- unique(warning_messages)
# print warnings
lapply(warning_messages, function(x){ warning(x, call. = FALSE)})
}
return(result)
}
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sa'), progress = TRUE)
test
resolution
calculate_met_focal <- function(landscape,
n_row,
n_col,
resolution,
points,
what,
...) {
# convert focal window to matrix
raster_window <- matrix(landscape, n_row, n_col)
# match function name
foo <- get(what, mode = "function")
# get provided arguments
arguments_provided <- substitute(...())
# landscape argument
arguments_values <- list(raster_window)
if (length(arguments_provided) >= 1) {
# combine raster with arguments provided
arguments_values <- c(arguments_values, arguments_provided)
}
# run function
result <- do.call(what = foo,
args = arguments_values)
return(result)
}
# try to hack the landscapemetrics version, but make it work for our purposes
focal_metrics <- function(x,
window,
metrics,
progress,
...) {
# check if window has uneven sides
if (any(dim(window) %% 2 == 0)) {
stop("The window must have uneven sides.", call. = FALSE)
}
number_metrics <- length(metrics)
# get coordinates of cells
points <- landscapemetrics::raster_to_points(x)[, 2:4]
# resolution of original raster
resolution <- raster::res(x)
# get dimensions of window
n_row <- nrow(window)
n_col <- ncol(window)
# create object for warning messages
warning_messages <- character(0)
result <- withCallingHandlers(expr = {lapply(seq_along(metrics), function(current_metric) {
# print progess using the non-internal name
if (progress) {
cat("\r> Progress metrics: ", current_metric, "/", number_metrics)
}
raster::focal(x = landscape, w = window, fun = function(x) {
calculate_met_focal(landscape = x,
n_row = n_row,
n_col = n_col,
resolution = resolution,
points = points,
what = metrics[[current_metric]],
...)},
pad = TRUE, padValue = NA)
})},
warning = function(cond) {
warning_messages <<- c(warning_messages, conditionMessage(cond))
invokeRestart("muffleWarning")})
names(result) <- metrics
if (progress) {cat("\n")}
# warnings present
if (length(warning_messages) > 0) {
# only unique warnings
warning_messages <- unique(warning_messages)
# print warnings
lapply(warning_messages, function(x){ warning(x, call. = FALSE)})
}
return(result)
}
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sa'), progress = TRUE)
test
devtools::load_all()
rm(list = c('.calculate_met_focal', 'focal_metrics'))
devtools::load_all()
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sa'), progress = TRUE)
test
devtools::load_all()
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sa'), progress = TRUE)
test
plot(test)
plot(test$sa)
?sbi
?sci
?sku
test = focal_metrics(x = normforest, window = matrix(1, 5, 5), metrics = list('sku'), progress = TRUE, excess = TRUE)
sku(normforest)
test
plot(sku$normforest)
plot(test$sku)
?srw
?std
devtools::load_all()
std(normforest)
option
option = c(1,2)
c(1,2) %in% option
devtools::load_all()
std(normforest)
std(normforest, option = 2)
std(normforest, option = 1)
devtools::load_all()
std(normforest)
std(normforest, option = 1)
srw(normforest)
srw(normforest, option = c(1,2))
srw(normforest, option = c(1,3))
srw(normforest, option = c(3))
?focal
devtools::load_all()
test = focal_metrics(x = as.matrix(normforest), window = matrix(1,5,5), metrics = list('sa'), progress = TRUE)
devtools::load_all()
test = focal_metrics(x = as.matrix(normforest), window = matrix(1,5,5), metrics = list('sa'), progress = TRUE)
class(normforest)
class(as.matrix(normforest))
devtools::load_all()
test = focal_metrics(x = as.matrix(normforest), window = matrix(1,5,5), metrics = list('sa'), progress = TRUE)
x = as.matrix(normforest)
x
window
if (class(x)[1] == "matrix") {
x <- as.raster(x)
}
x <- raster(x)
x
devtools::load_all()
test = focal_metrics(x = as.matrix(normforest), window = matrix(1,5,5), metrics = list('sa'), progress = TRUE)
plot(test)
plot(test$sa)
x
x = as.matrix(normforest)
raster(x)
normforest
devtools::document()
?focal_metrics
devtools::document()
?focal_metrics
