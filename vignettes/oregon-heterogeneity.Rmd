---
title: "Basic geodiv Applications"
author: "Annie C. Smith"
date: "October 30, 2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{oregon-heterogeneity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting Started

First, import *geodiv* and any other necessary packages (for this example).

```{r setup, include = FALSE}

library(geodiv)
library(raster)
library(ggplot2)
library(viridis)
library(ggpubr)

```

One of the common uses of *geodiv* will be to look at heterogeneity of landscapes. The easiest way to visualize heterogeneity, or landscape texture, is in terms of elevation. However, the functions in *geodiv* can be applied to any image or matrix. Here, we'll look at the various measures of landscape heterogeneity for both elevation and a measure of greenness, the Normalized Difference Vegetation Index (NDVI). 

Example rasters of both elevation and NDVI over a portion of southwestern Oregon, USA are contained in the *geodiv* package. To begin, we will open and examine these rasters.

```{r data1}

# import NDVI and elevation rasters into R
data(orforest)
data(orelevation)

```

Next, we want to take a look at what those datasets include. Note that the help files contain information on the extent and resolution of the rasters, as well as potential scalar values for the data. 

```{r data2}

# look up scalar and apply to data
?orelevation
?orforest

```

Now we can make maps to see what the rasters look like. These examples cover the same region in Oregon, and are at the same resolution.

```{r data3}

# plot maximum growing season EVI for Oregon
plot(orforest, xlab = 'Longitude', ylab = 'Latitude', main = 'Growing Season NDVI')

# plot elevation (in meters) for Oregon
plot(orelevation, xlab = 'Longitude', ylab = 'Latitude', main = 'Elevation (m)')

```

# Preparing data

The primary purpose of *geodiv* is to provide simple methods for calculating gradient surface metrics. The package was developed to allow for calculations on satellite imagery, but can also be applied to any raster image or matrix. The following sections describe the basic functions available and demonstrate some example outputs.

##Removing the Best Fit Plane

For surface metrics, we often don't really care about the actual values of an image so much as their contrast (heterogeneity). Because of this, we now want to remove any trends that there may be over the rasters. For example, if there is a large increase in elevation over an area, we often don't care about the larger trend, but want to know how complex the region is as a whole, or at smaller scales. 

Removing the trend over a raster or matrix is made easy by the 'remove_plane' function. This function removes the best-fit polynomial plane from the surface, considering polynomial planes of orders 0 --3. If no trend is identified (polynomial plane of order 0), the function removes the mean value from the raster.

Note that this function prints the order of polynomial that best fits any trend in the data. While only polynomials of orders 0 -- 3 are considered in 'remove_plane,' if you want a custom order of polynomial, you can use the 'fitplane' function to calculate the best fit plane of that order polynomial.

```{r remove trend}

# remove overall trends in values over rasters (this removes the best-fit polynomial plane)
ndvi <- remove_plane(orforest)
elev <- remove_plane(orelevation)

# plot the new rasters
plot(ndvi, xlab = 'Longitude', ylab = 'Latitude', main = 'Growing Season NDVI - no trend')
plot(elev, xlab = 'Longitude', ylab = 'Latitude', main = 'Elevation (m) - no trend')

```

By plotting the new rasters, we see that the NDVI image was not changed (polynomial of order 0), except for the actual values. However, the elevation raster now looks quite different now that a linear plane (order 1) was removed, with heterogeneity more pronounced.

# Calculating Metrics

We now have clean rasters. With these rasters, users will often want to do one of two tasks:

(1) Determine the overall value of metrics over the entire image.
(2) Create texture images of several metrics to observe patterns of heterogeneity over the landscape.

First, we will calculate metrics using the entire image.

## Calculating metrics over an entire surface

We can run all the functions using a wrapper function that will print the metric being calculated and the result. Usually, users will only want to use one or several of these functions. 

Almost all of the surface metric functions take either a raster or matrix, and return a vector of numeric values. Sfd (3D fractal dimension) does not accept rasters, only matrices. While most functions return single values, several functions calculate multiple, highly related, values at once. These functions return a vector, with the order of returned values described in the function help files.

The functions returning multiple values are Std (texture direction metrics), Str (texture aspect ratio), Srw (radial wavelength metrics), and Scl (correlation lengths). Both Std and Srw return values representing different metrics. For example, Std returns values for Std (angle of dominating texture) as well as Stdi (texture direction index). Str and Scl return one or more values of the same metric, for different input values. For example, Scl returns the correlation distance to various thresholds of autocorrelation (e.g., 20% or 37%).

Currently, functions only accept single-band, or single-layer rasters and matrices. 

``` {r single example}

# create function to run all functions and output results
run_all <- function(r){

  # run all functions
  sa <- sa(r)
  cat('Sa: ', sa, '\n')
  
  sq <- sq(r)
  cat('Sq: ', sq, '\n')
  
  s10z <-s10z(r)
  cat('S10z: ', s10z, '\n')

  sdq <- sdq(r)
  cat('Sdq: ', sdq, '\n')

  sdq6 <- sdq6(r)
  cat('Sdq6: ', sdq6, '\n')

  sdr <- sdr(r)
  cat('Sdr: ', sdr, '\n')

  sbi <- sbi(r)
  cat('Sbi: ', sbi, '\n')
  
  sci <- sci(r)
  cat('Sci: ', sci, '\n')

  ssk_adj <- ssk(r, adj = TRUE)
  cat('Ssk (adjusted): ', ssk_adj, '\n')
  
  sku_excess <- sku(r, excess = TRUE)
  cat('Sku (excess): ', sku_excess, '\n')

  sds <- sds(r)
  cat('Sds: ', sds, '\n')

  sfd <- sfd(as.matrix(r))
  cat('Sfd: ', sfd, '\n')

  srwvals <- srw(r, plot = FALSE) 
  cat('Srw: ', srwvals[1], '\n')
  cat('Srwi: ', srwvals[2], '\n')
  cat('Shw: ', srwvals[3], '\n')

  stdvals <- std(r, plot = FALSE)
  cat('Std: ', stdvals[1], '\n')
  cat('Stdi: ', stdvals[2], '\n')
  
  svi <- svi(r)
  cat('Svi: ', svi, '\n')

  strvals <- str(r, threshold = c(0.2, 1 / exp(1)))
  cat('Str (20%): ', strvals[1], '\n')
  cat('Str (37%): ', strvals[2], '\n')

  ssc <- ssc(r)
  cat('Ssc: ', ssc, '\n')

  sv <- sv(r)
  cat('Sv: ', sv, '\n')

  sp <- sph(r)
  cat('Sp: ', sp, '\n')

  sk <- sk(r)
  cat('Sk: ', sk, '\n')

  smean <- smean(r)
  cat('Smean: ', smean, '\n')

  spk <- spk(r)
  cat('Spk: ', spk, '\n')

  svk <- svk(r)
  cat('Svk: ', svk, '\n')

  sclvals <- scl(r, threshold = c(0.2, 1 / exp(1)), plot = FALSE)
  cat('Scl (20%): ', sclvals[1], '\n')
  cat('Scl (37%): ', sclvals[2], '\n')

  sdc0_5 <- sdc(r, 0, 0.05)
  cat('Sdc 0-5%: ', sdc0_5, '\n')

  sdc50_55 <- sdc(r, 0.50, 0.55)
  cat('Sdc 50-55%: ', sdc50_55, '\n')

  sdc80_85 <- sdc(r, 0.80, 0.85)
  cat('Sdc 80-85%: ', sdc80_85, '\n')

  return(cat('Finished with raster.', '\n'))
}

# run all functions on the images
run_all(ndvi)
run_all(elev)

```

Note that several of these functions (Srw, Std, Str, Scl) returned warnings. This is fine, and is due to the fact that they include summaries over certain portions of Fourier transform images. We can see what the Srw and Std functions are doing by using the plotting option. Values are derived by summarizing the displayed raster over the lines in the figures. Str and Scl use the autocorrelation image, which is similar to those used for the Srw and Std functions.

```{r plot extraction functions}

srwvals <- srw(elev, plot = TRUE) 
stdvals <- std(elev, plot = TRUE)

```

## Creating texture images

Another common use for *geodiv* is to run the surface metric functions over windows surrounding each pixel to create texture images. 

For this example, we will only use a few of the functions, as some may take a while on a laptop. For more complex functions (e.g., Str, S10z, Srw, etc.), it is suggested that users run this type of analysis on larger computers or clusters with many cores.

The 'texture_image' function is a wrapper for the 'window_metric' function, which allows users to extract metrics for portions of a raster. The 'texture_image' function applies the selected function to windows around every pixel or cell within a raster or matrix.

The arguments to 'texture_image' include the window shape (square or circular), the size of the window in pixels or meters, an equal area projection code, the metric name, and several parallel options (number of cores, number of clumps into which to group pixels). The function may be run serially or in parallel. It uses the 'mclapply' function from the *parallel* package to parallelize functions on Linux and Mac systems, and 'parLapply' on Windows systems. If window size is given in meters, it is converted to an approximate size in number of pixels, so it is usually preferred to give a pixel number to the size argument.

One important aspect of the 'texture_image' function is that it always converts rasters to an equal area projection so that the 'window_metric' function can work with matrices. Users will need to identify an appropriate equal area projection for their study, rather than using the default, in order for this function to return unbiased results.

``` {r all points}

# Sa (average surface roughness)
ndvi_sa_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sa', NULL, TRUE, 2, 6)
elev_sa_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sa', NULL, TRUE, 2, 6)

# Smean (mean peak height - only positive values)
ndvi_smean_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'smean', NULL, TRUE, 2, 6)
elev_smean_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'smean', NULL, TRUE, 2, 6)

# Sfd (3d fractal dimension)
ndvi_sfd_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sfd', NULL, TRUE, 2, 6)
elev_sfd_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sfd', NULL, TRUE, 2, 6)

# Sku (kurtosis)
ndvi_sku_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sku', NULL, TRUE, 2, 6)
elev_sku_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sku', NULL, TRUE, 2, 6)

# Sdc (height intervals along bearing area curve (distribution of values))
# this may take a minute or two to complete
ndvi_sdc_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sdc', list(low = 0, high = 0.2), TRUE, 2, 6)
elev_sdc_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sdc', list(low = 0, high = 0.2), TRUE, 2, 6)

# Sci (core fluid retention index)
# this may take a few minutes to complete
ndvi_sci_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sci', NULL, TRUE, 2, 6)
elev_sci_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sci', NULL, TRUE, 2, 6)

# add results to a matrix
ndvi_mat <- matrix(c(getValues(ndvi_sa_img), getValues(ndvi_smean_img), getValues(ndvi_sfd_img), getValues(ndvi_sku_img), getValues(ndvi_sdc_img), getValues(ndvi_sci_img)), nrow = length(ndvi_sa_img), ncol = 6)

elev_mat <- matrix(c(getValues(elev_sa_img), getValues(elev_smean_img), getValues(elev_sfd_img), getValues(elev_sku_img), getValues(elev_sdc_img), getValues(elev_sci_img)), nrow = length(elev_sa_img), ncol = 6)

# add column names
colnames(ndvi_mat) <- c('sa', 'smean', 'sfd', 'sku', 'sdc', 'sci')
colnames(elev_mat) <- c('sa', 'smean', 'sfd', 'sku', 'sdc', 'sci')

```

## Visualization

We now have metrics for all pixels in the image. A typical next step is to visualize these metrics over the region. 

We'll start by exploring the raw results by looking at distributions of the metrics for elevation. 

```{r hist metrics}

# distributions of a few variables for elevation
hist(elev_mat[, 1], breaks = 30, main = 'Histogram of Elevation Sa')
hist(elev_mat[, 2], breaks = 30, main = 'Histogram of Elevation Smean')
hist(elev_mat[, 3], breaks = 30, main = 'Histogram of Elevation Sfd')
hist(elev_mat[, 4], breaks = 30, main = 'Histogram of Elevation Sku')
hist(elev_mat[, 5], breaks = 30, main = 'Histogram of Elevation Sdc')
hist(elev_mat[, 6], breaks = 30, main = 'Histogram of Elevation Sci')

```

Histograms demonstrate some variation in the values across the image, but we're typically more interested in the spatial distribution of the values. 

```{r map metrics}

# create df for ggplot
ndvi_df <- as.data.frame(ndvi_mat)
ndvi_df$x <- coordinates(ndvi_sa_img)[, 1]
ndvi_df$y <- coordinates(ndvi_sa_img)[, 2]
ndvi_df$ind <- seq(1, length(ndvi_sa_img))

elev_df <- as.data.frame(elev_mat)
elev_df$x <- coordinates(elev_sa_img)[, 1]
elev_df$y <- coordinates(elev_sa_img)[, 2]
elev_df$ind <- seq(1, length(elev_sa_img))

# create plots - ndvi
ndvi_sa_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = sa)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
ndvi_smean_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = smean)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
ndvi_sku_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = sku)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
ndvi_sfd_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = sfd)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
ndvi_sdc_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = sdc)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
ndvi_sci_plot <- ggplot(ndvi_df, aes(x = x, y = y, fill = sci)) +
  geom_tile() +
  scale_fill_viridis() +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))

# combine plots - ndvi
ggarrange(ndvi_sa_plot, ndvi_smean_plot, ndvi_sku_plot, ndvi_sfd_plot, ndvi_sdc_plot, ndvi_sci_plot, labels = c('Sa', 'Smean', 'Sku', 'Sfd', 'Sdc', 'Sci'), nrow = 2, ncol = 3)

# create plots - elev
elev_sa_plot <- ggplot(elev_df, aes(x = x, y = y, fill = sa)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
elev_smean_plot <- ggplot(elev_df, aes(x = x, y = y, fill = smean)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
elev_sku_plot <- ggplot(elev_df, aes(x = x, y = y, fill = sku)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
elev_sfd_plot <- ggplot(elev_df, aes(x = x, y = y, fill = sfd)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
elev_sdc_plot <- ggplot(elev_df, aes(x = x, y = y, fill = sdc)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))
elev_sci_plot <- ggplot(elev_df, aes(x = x, y = y, fill = sci)) +
  geom_tile() +
  scale_fill_gradient(low = 'white', high = 'black') +
  coord_equal() +
  theme_bw() +
  theme(panel.grid = element_blank(),
        axis.text = element_blank(),
        axis.title = element_text(size = 14))

# combine plots - elev
ggarrange(elev_sa_plot, elev_smean_plot, elev_sku_plot, elev_sfd_plot, elev_sdc_plot, elev_sci_plot, labels = c('Sa', 'Smean', 'Sku', 'Sfd', 'Sdc', 'Sci'), nrow = 2, ncol = 3)

```

This produces some interesting patterns that highlight various aspects of the two images (e.g., ridges and valleys; harvested areas). 

From this point, users will typically want to relate values to other variables (e.g., field data collected at points) or move on to other more detailed analyses. 



