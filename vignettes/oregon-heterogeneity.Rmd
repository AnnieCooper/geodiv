---
title: "Assessing landscape heterogeneity in Oregon State"
author: "Annie C. Smith"
date: "October 28, 2019"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{oregon-heterogeneity}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Getting Started

First, import *geodiv* and any other necessary packages.

```{r setup, include = FALSE}

library(geodiv)
library(raster)
library(mapdata)
library(maptools)
library(rgeos)
library(ggplot2)

```

Now, open and plot rasters of the Normalized Difference Vegetation Index (NDVI) and
SRTM elevation for a portion of southwestern Oregon.

First, we want to open the data.
```{r data1}

# import NDVI and elevation rasters into R
data(orforest)
data(orelevation)

```

Next, we want to take a look at what those datasets include. 

```{r data2}

# look up scalar and apply to data
?orelevation
?orforest

```

Now, we can make maps to see what the rasters look like.

```{r data3}

# plot maximum growing season EVI for Oregon
plot(orforest, xlab = 'Longitude', ylab = 'Latitude', main = 'Growing Season NDVI')

# plot elevation (in meters) for Oregon
plot(orelevation, xlab = 'Longitude', ylab = 'Latitude', main = 'Elevation (m)')

```

# Metric Calculations

##Removing the Best Fit Plane

For surface metrics, we don't really care about the actual values so much as their contrast. Because of this, we now want to remove any trends that there may be over the rasters. This is made easy by a function included in *geodiv*, 'remove_plane.' Even if no trend is located (polynomial plane of order 0), we remove the mean value from the raster.

Note that this returned the order of polynomial that best fits any trend in the data. This is process is automated and considers polynomials of orders of 0 -- 3. If you want a custom order of polynomial, you can use the 'fitplane' function to calculate the best fit plane of that order polynomial.

```{r remove trend}

# remove overall trends in values over rasters (this removes the best-fit polynomial plane)
ndvi <- remove_plane(orforest)
elev <- remove_plane(orelevation)

# plot the new rasters
plot(ndvi, xlab = 'Longitude', ylab = 'Latitude', main = 'Growing Season NDVI - no trend')
plot(elev, xlab = 'Longitude', ylab = 'Latitude', main = 'Elevation (m) - no trend')

```

By plotting the new rasters, we see that the NDVI image was not changed, except for the actual values. However, the elevation raster now looks quite different now, with heterogeneity more pronounced.

For now, let's keep the results of the 'remove_plane' function and take a look at the results.

## Sampling Locations

We now have clean rasters. With these rasters, we want to do two tasks:

(1) Determine the overall value of metrics over the entire image.
(2) Create a texture image of several metrics to observe patterns of heterogeneity over the landscape.

First, we will calculate metrics using the entire image.

## Calculating metrics for a single image

We run all the functions using a wrapper function that will print the metric being calculated and the result.

``` {r single example}

# create function to run all functions and output results
run_all <- function(r){

  # run all functions
  cat('Sa: ', '\n')
  sa <- sa(r)
  print(sa)
  cat('\n')

  cat('Sq: ', '\n')
  sq <- sq(r)
  print(sq)
  cat('\n')

  cat('S10z: ', '\n')
  s10z <-s10z(r)
  print(s10z)
  cat('\n')

  cat('Sdq: ', '\n')
  sdq <- sdq(r)
  print(sdq)
  cat('\n')

  cat('Sdq6: ', '\n')
  sdq6 <- sdq6(r)
  print(sdq6)
  cat('\n')

  cat('Sdr: ', '\n')
  sdr <- sdr(r)
  print(sdr)
  cat('\n')

  cat('Sbi: ', '\n')
  sbi <- sbi(r)
  print(sbi)
  cat('\n')

  cat('Sci: ', '\n')
  sci <- sci(r)
  print(sci)
  cat('\n')

  cat('Ssk (adjusted): ', '\n')
  ssk_adj <- ssk(r, adj = TRUE)
  print(ssk_adj)
  cat('\n')

  cat('Sku (excess): ', '\n')
  sku_excess <- sku(r, excess = TRUE)
  print(sku_excess)
  cat('\n')

  cat('Sds: ', '\n')
  sds <- sds(r)
  print(sds)
  cat('\n')

  cat('Sfd: ', '\n')
  sfd <- sfd(as.matrix(r))
  print(sfd)
  cat('\n')

  cat('Srw function - no plotting: ', '\n')
  srwvals <- srw(r, plot = FALSE) # this takes a while
  print(srwvals)
  cat('\n')

  cat('Srw: ', '\n')
  srw <- srwvals[[1]]
  print(srw)
  cat('\n')

  cat('Srwi: ', '\n')
  srwi <- srwvals[[2]]
  print(srwi)
  cat('\n')

  cat('Shw: ', '\n')
  shw <- srwvals[[3]]
  print(shw)
  cat('\n')

  cat('Std function - no plotting: ', '\n')
  stdvals <- std(r, plot = FALSE)
  print(stdvals)
  cat('\n')

  cat('Std: ', '\n')
  std <- stdvals[[1]]
  print(std)
  cat('\n')

  cat('Stdi: ', '\n')
  stdi <- stdvals[[2]]
  print(stdi)
  cat('\n')

  cat('Svi: ', '\n')
  svi <- svi(r)
  print(svi)
  cat('\n')

  cat('Str function: ', '\n')
  strvals <- str(r, threshold = c(0.2, 1 / exp(1)))
  print(strvals)
  cat('\n')

  cat('Str (20%): ', '\n')
  str20 <- strvals[[1]]
  print(str20)
  cat('\n')

  cat('Str (37%): ', '\n')
  str37 <- strvals[[2]]
  print(str37)
  cat('\n')

  cat('Ssc: ', '\n')
  ssc <- ssc(r)
  print(ssc)
  cat('\n')

  cat('Sv: ', '\n')
  sv <- sv(r)
  print(sv)
  cat('\n')

  cat('Sp: ', '\n')
  sp <- sph(r)
  print(sp)
  cat('\n')

  cat('Sk: ', '\n')
  sk <- sk(r)
  print(sk)
  cat('\n')

  cat('Smean: ', '\n')
  smean <- smean(r)
  print(smean)
  cat('\n')

  cat('Spk: ', '\n')
  spk <- spk(r)
  print(spk)
  cat('\n')

  cat('Svk: ', '\n')
  svk <- svk(r)
  print(svk)
  cat('\n')

  cat('Scl function - no plotting: ', '\n')
  sclvals <- scl(r, threshold = c(0.2, 1 / exp(1)), plot = FALSE)
  print(sclvals)
  cat('\n')

  cat('Scl (20%): ', '\n')
  scl20 <- sclvals[[1]] # never gets to 0.2
  print(scl20)
  cat('\n')

  cat('Scl (37%): ', '\n')
  scl37 <- sclvals[[2]]
  print(scl37)
  cat('\n')

  cat('Sdc 0-5%: ', '\n')
  sdc0_5 <- sdc(r, 0, 0.05)
  print(sdc0_5)
  cat('\n')

  cat('Sdc 50-55%: ', '\n')
  sdc50_55 <- sdc(r, 0.50, 0.55)
  print(sdc50_55)
  cat('\n')

  cat('Sdc 80-85%: ', '\n')
  sdc80_85 <- sdc(r, 0.80, 0.85)
  print(sdc80_85)
  cat('\n')

  return(cat('Finished with raster.', '\n'))
}

```

Once we have the function written, we apply it to the entire image.

```{r single point3}

# run all functions on the images
run_all(ndvi)
run_all(elev)

```


Note that several of these functions (Srw, Std, Str, Scl) returned warnings. This is fine, and is due to the fact that they include summaries over certain portions of Fourier transform images. We can see what the Srw and Std functions are doing by using the plotting option. Values are derived by summarizing the displayed raster over the lines in the figures. Str and Scl use the autocorrelation image, which is similar to those used for the Srw and Std functions.

```{r plot extraction functions}

srwvals <- srw(elev, plot = TRUE) 
stdvals <- std(elev, plot = TRUE)

```

Now we want to run the functions over windows surrounding each pixel to create a texture image. Once the texture images are created, we can add the results to a dataframe.

For this example, we will only use a few of the functions, as some may take a while on a laptop. For more complex functions (e.g., Str, S10z, Srw, etc.), it is suggested that users run this type of analysis on larger computers or clusters with many cores.

``` {r all points}

# Sa (average surface roughness)
ndvi_sa_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sa', NULL, TRUE, 2, 6)
elev_sa_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sa', NULL, TRUE, 2, 6)

# Smean (mean peak height)
ndvi_smean_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'smean', NULL, TRUE, 2, 6)
elev_smean_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'smean', NULL, TRUE, 2, 6)

# Sfd (3d fractal dimension)
ndvi_sfd_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sfd', NULL, TRUE, 2, 6)
elev_sfd_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sfd', NULL, TRUE, 2, 6)

# Sku (kurtosis)
ndvi_sku_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sku', NULL, TRUE, 2, 6)
elev_sku_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sku', NULL, TRUE, 2, 6)

# Str (texture aspect ratio)
ndvi_sdc_img <- texture_image(ndvi, 'square', 5, in_meters = FALSE, 5070, 'sdc', list(low = 0, high = 0.2), TRUE, 2, 6)
elev_sdc_img <- texture_image(elev, 'square', 5, in_meters = FALSE, 5070, 'sdc', list(low = 0, high = 0.2), TRUE, 2, 6)

# STILL EDITING FROM HERE DOWN
```

## Visualization

We now have metrics for all of the sampling locations. We want to see if the metrics result in any natural grouping of the sites. We'll start investigating this by exploring the raw results. Let's look at distributions of a few metrics first. 

```{r map metrics}

# distributions of a few variables
hist(data_elev$value[data_elev$metric == 'sa'], breaks = 30)
hist(data_elev$value[data_elev$metric == 'sbi'], breaks = 30)
hist(data_elev$value[data_elev$metric == 'sfd'], breaks = 30)
hist(data_elev$value[data_elev$metric == 'std'], breaks = 30)

```

Histograms demonstrate some variation in the values at the sampling locations, but this doesn't tell us very much about how those values relate to various ecosystem properties. To look at those relationships, let's map the metrics across the state.

```{r map metrics}

# for plotting, convert raster values to dataframe
elev_pixdf <- as(oregonElev, "SpatialPixelsDataFrame")
elev_df <- as.data.frame(elev_pixdf)
colnames(elev_df) <- c("value", "x", "y")

evi_pixdf <- as(oregonEVI, "SpatialPixelsDataFrame")
evi_df <- as.data.frame(evi_pixdf)
colnames(evi_df) <- c("value", "x", "y")

# map the metrics for elevation
or_ggpoly <- map_data('state', 'oregon')

### for Elevation
# Sq
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev[data_elev$metric == 'sq',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sq') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sdq
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev[data_elev$metric == 'sdq',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sdq') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sbi
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev[data_elev$metric == 'sbi',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sbi') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sfd
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev[data_elev$metric == 'sfd',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sfd') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

# and also for EVI
# Sq
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi[data_evi$metric == 'sq',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sq') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sdq
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi[data_evi$metric == 'sdq',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sdq') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sbi
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi[data_evi$metric == 'sbi',], aes(x = x, y = y, size = value)) +
  scale_size_continuous('Sbi') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# Sfd
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi[data_evi$metric == 'sfd',], aes(x = x, y = y, size = value)) +
  scale_size_continuous(name = 'Sfd') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

```

There aren't really any clear patterns in the map of texture direction, although it does appear that the texture direction of elevation in mountainous areas tends to be closer to 0, and in flatter areas closer to 180. We will combine metrics next in order to try improve to our ability to distinguish ecosystems. 

We now want to investigate the observed groupings using a statistical approach that simplifies the many metrics into fewer groups, principal components analysis. The composition of the various components provides information on which metrics contain similar information. By observing how the first two or three principal components relate to one another, we can potentially split sites into ecosystems with various characteristics.

First, we have to clean up the data by reshaping it and removing any missing values.

```{r pca}

library(tidyverse)

# transform data into correct format (columns for each metric)
data_elev <- spread(data = data_elev, key = metric, value = value)
data_evi <- spread(data = data_evi, key = metric, value = value)

# order neatly
data_elev <- data_elev[order(data_elev$point),]
data_evi <- data_evi[order(data_evi$point),]

# we should now have 108 neatly ordered rows
nrow(data_elev)
head(data_elev)

# check for missing values
sapply(data_elev[, c(4:30, 32:35)], function(x) sum(is.na(x)))

# str20 has one missing value, which makes sense because it means that autocorrelation
# never decreases to 20% in that area
# for now, we will remove that point, and any others with missing locations

data_elev_noNA <- na.omit(data_elev) # now 97 points
data_evi_noNA <- na.omit(data_evi) # now 107 points

```

We located a few missing values in the texture aspect ratio (Str) and correlation length functions (Scl). 

This makes a lot of sense, because the correlation length function determines the distance it takes to get the autocorrelation within the raster down to a specified value. Here, we see that the distance for an autocorrelation value of 37% is successfully estimated, but the distance for an autocorrelation value of 20% is not. This simply indicates that the raster values are highly autocorrelated in this area and do not ever decrease to 20%. We can see this high autocorrelation by looking at the autocorrelation function image.

We also note missing values in the 3D fractal dimension (Sfd), mean peak height (Smean), and summit curvature (Ssc) variables. These are likely due to entirely flat areas of the landscape, where no peaks or patterns may be found.

```{r autocorrelation}

# show autocorrelation image for sample point with missing str20 and scl20 values

```

Now that we have investigated the data and decided which variables we can and want to use, we calculate the principal components using the function 'prcomp.'

```{r pca1}

# calculate principal components
elev_prc <- prcomp(data_elev_noNA, center = TRUE, scale = TRUE)
evi_prc <- prcomp(data_evi_noNA, center = TRUE, scale = TRUE)
summary(elev_prc)
summary(evi_prc)

# take a look at the components for elevation
screeplot(elev_prc, type = "l", npcs = 15, main = "Screeplot of the first 10 PCs")
abline(h = 1, col = "red", lty = 5)
legend("topright", legend = c("Eigenvalue = 1"),
       col = c("red"), lty = 5, cex = 0.6)

cumpro <- cumsum(elev_prc$sdev ^ 2 / sum(elev_prc$sdev ^ 2))
plot(cumpro[0:15], xlab = "PC #", ylab = "Amount of explained variance", main = "Cumulative variance plot")
abline(v = 6, col = "blue", lty = 5)
abline(h = 0.77001, col = "blue", lty = 5)
legend("topleft", legend = c("Cut-off @ PC6"),
       col = c("blue"), lty = 5, cex = 0.6)

# the first 2 components explain 44% of the variance, while the first three explain 56%

# let's plot the first 2
plot(elev_prc$x[, 1], elev_prc$x[, 2], xlab = "PC1 (28.1%)", ylab = "PC2 (16.3%)", main = "PC1 / PC2 - plot")

plot(elev_prc$x[, 1], elev_prc$x[, 3], xlab = "PC1 (28.1%)", ylab = "PC3 (11.5%)", main = "PC1 / PC3 - plot")

plot(elev_prc$x[, 2], elev_prc$x[, 3], xlab = "PC2 (16.3%)", ylab = "PC3 (11.5%)", main = "PC2 / PC3 - plot")

# how about mapping - are there any patterns?
data_elev_noNA$prc1 <- elev_prc$x[, 1]
data_elev_noNA$prc2 <- elev_prc$x[, 2]
data_elev_noNA$prc3 <- elev_prc$x[, 3]

data_evi_noNA$prc1 <- evi_prc$x[, 1]
data_evi_noNA$prc2 <- evi_prc$x[, 2]
data_evi_noNA$prc3 <- evi_prc$x[, 3]


### elevation
# principal component 1
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev_noNA, aes(x = x, y = y, size = prc1)) +
  scale_size_continuous(name = 'PC 1') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# principal component 2
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev_noNA, aes(x = x, y = y, size = prc2)) +
  scale_size_continuous(name = 'PC 2') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# principal component 3
ggplot(data = elev_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'Elevation (m)') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_elev_noNA, aes(x = x, y = y, size = prc3)) +
  scale_size_continuous(name = 'PC 3') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

### evi
# principal component 1
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'EVI') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi_noNA, aes(x = x, y = y, size = prc1)) +
  scale_size_continuous(name = 'PC 1') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# principal component 2
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'EVI') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi_noNA, aes(x = x, y = y, size = prc2)) +
  scale_size_continuous(name = 'PC 2') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())
# principal component 3
ggplot(data = evi_df) +
  geom_raster(aes(x = x, y = y, fill = value), alpha = 0.8) + 
  scale_fill_gradientn(colours = terrain.colors(10), name = 'EVI') +
  geom_polygon(data = or_ggpoly, aes(x = long, y = lat, group = region), fill = NA, colour = 'black') +
  geom_point(data = data_evi_noNA, aes(x = x, y = y, size = prc3)) +
  scale_size_continuous(name = 'PC 3') +
  theme_bw() +
  theme(panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

```

While the individual principal components don't show any clustering, we can see what they represent when we map the results. The first principal component appears to be linked with areas of high contrast in EVI values (e.g., borders of forest and urban areas), while the second clearly represents the drier eastern side of the state versus the wetter western side of the state. It isn't clear what the third component represents; however, the primary variables included in that component are the ten-point height of EVI and the summit curvature around the highest peaks. Both variables should be linked to areas of how 'peaked' the EVI surface appears.

We investigate these patterns further by applying thresholds to the map to find low or high areas.

```{r apply clustering}

# what do various cutoffs for principal component 1 show?
ggplot() +
  geom_tile(data = evi_df, aes(x = x, y = y, fill = value), alpha = 0.8) + 
  geom_point(data = data[data$prc1 <= 50,], aes(x = x, y = y, size = prc1))

# what do various cutoffs for principal component 2 show?
ggplot() +
  geom_tile(data = evi_df, aes(x = x, y = y, fill = value), alpha = 0.8) + 
  geom_point(data = data[data$prc2 >= 0.5,], aes(x = x, y = y, size = prc2))

# what do various cutoffs for principal component 3 show?


```

The second principal component is clearly associated with lower and flatter EVI values, as all positive values of the component are in the unforested or relatively unforested areas of Oregon.

discuss results. explain mapping of clusters.

```{r map clusters}
```

final discussion of results and implications
